---
title: 20220413组会汇报
create-date: 2022-04-06-23-25
latest-date: 2022-04-06-23-26
---
# MatLab/C++混合编程笔记
create-date: 2022-04-06-23-25 &emsp;&emsp;&emsp;&emsp;latest-date: 2022-04-07-11-26

本文大致梳理了从开始接触MatLab/C++混合编程至今学到的一点皮毛和自己摸出来的一点教训。包括但不限于MatLab/C++混合编程模型的认识，一些常用的API/写法，一些注意的点。随学随记，想起来就写，不定期更。

## MatLab/C++混合编程的目的
最直接的目的，也是我接触这个技术的初衷，还是因为现有的MatLab程序运行速度难以满足实际需求。例如在实验室的实际项目中，对于许多组数据中的一个需要运行四五个.m文件，这些.m文件中的单个函数经过多次循环调用，往往需要耗时上千秒。这样一来全数据全脚本所需的运行时间就更加难以接受。
C++以运行速度快著称，因此引入由C++编写的函数，以MatLab规定的方式编译后被MatLab调用，能够起到加快程序运行速度的作用。

## MatLab与C++的主要区别
MatLab与C++的主要区别包括：
- MatLab是由解释器解释执行的解释型语言，而C++是由编译器编译为二进制可执行文件的编译型语言。
- MatLab是动态类型语言，同一个变量的类型可以随着程序运行而改变。而C++是静态类型语言，变量的类型在编译期由编译器确定。
    - *但需要注意的是，MatLab的变量并非没有类型。MatLab内部对类型问题的处理较完善也较为宽容，但与C++混合编程时，类型问题可能导致意想不到的问题。*

## 关于MatLab/C++混合编程模型
所谓MatLab/C++混合编程，本质上是用C++按照MatLab规定的范式进行开发，利用MatLab提供的编译工具```MEX```进行编译，最终以MatLab函数的形式调用编译得到的二进制文件。
 ### 数据的传递
 两种语言混合编程最关键的问题就是数据的传递方式。在MatLab/C++混合编程模型中，MatLab端与C++端的数据通信依靠指针数组的传递实现。以默认的回调入口函数为例：
 ```C++
void mexFunction(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]) {}
 ```
 ```mexFunction```是MatLab在混合编程模型中定义的统一的回调入口函数，在C、C++、Fortran中函数名一致。参数列表：
 - ```int nlhs``` 表示等号左侧的参数数量，即函数的输出变量个数
 - ```int nrhs``` 表示等号右侧的参数数量，即函数的输入变量个数
 - ```const mxArray* prhs[]``` 是一个指针数组，数组中的元素个数等于```nrhs```。```prhs```指向这个数组的首地址，数组中元素均为```mxArray*```类型的指针，指向对应的```mxArray```类对象。值得一提的是，在MatLab/C++混合编程模型中，MatLab端的一切数据类型，包括标量、向量、矩阵、张量、结构体、元胞、字符串等，在传递给C++端的时候均被包装成```mxArray```类的对象。数组中指针的顺序由MatLab端调用时的输入参数顺序决定。与```mxArray* plhs[]```不同的是，输入参数不允许被修改，是只读的，因此使用```const```关键字修饰。
 - ```mxArray* plhs[]``` 结构上与```const mxArray* prhs[]```类似，数组中的指针指向C++端传回MatLab端的结果参数。作为结果的```mxArray```类对象自然是可写的。

总结：MatLab与C++的数据通信通过传递指针实现。数据通信过程中除指针传递外，不会发生数据在内存中的读写，因此即便传递的是很大的高维张量，对于单个变量来说数据传递过程的时间复杂度均为O(1)。

 ### 编译环境
 虽然MatLab本身作为解释型语言，不需要编译后执行，但与MatLab进行混合编程的语言(C、C++、Fortran)均需要在MatLab提供的环境下进行编译，才能被MatLab调用。

 MatLab提供了MEX工具作为三种语言的统一的编译工具。MEX工具可以在MatLab命令行中调用，常用的格式为：
 ```shell
>> mex filename option1 ...optionN
 ```
 在这个常用格式中，参数```filename```是要编译的源文件，可以是一个或多个。值得注意的是，在多个源文件编译时，MEX默认的输出文件名以第一个文件名为准。若要自定义输出文件名，使用``` -output```编译选项。常用编译选项见后文。
 
 在不使用任何编译选项的默认条件下，MEX输出的文件格式在不同操作系统下各有不同：
 - Windows - .mexw64
 - Linux - .mexa64
 - MaxOs - .mexmaci64

后缀名结尾的64表示当前的MatLab版本为64位版本，若在32位MatLab版本下编译则以32结尾。注意：这里的64位、32位指MatLab版本，而非操作系统版本。

实际上，MEX的使用与gcc/g++较为类似。不同点在于MEX提供了默认的MatLab头文件，在```matlabroot\extern\include```路径下，包括```mex.h```、```mat.h```、```matrix.h```等。其中最常用的是```mex.h```，其中声明了包括```mexFunction```在内的大量常用函数。```mxArray```类在```matrix.h```中声明。

MEX默认输出的```.mexw64```/```.mexa64```/```.mexmaci64```本质上是只能在MatLab环境下调用的动态链接库，一次编译后能够被MatLab解释器反复加载调用。关于动态链接库的背景知识：[冷冰若水-第十九讲：动态链接库](https://www.cnblogs.com/lit10050528/p/3733381.html)

# MatLab/C++混合编程流程
MatLab/C++混合编程的流程大致可分为以下步骤：
- 数据传入
    - 数据类型、大小检查
    - 转为C++侧通用的类型
- 数据处理，这部分包含了主要的代码逻辑
- 结果返回，可以看作数据传入的逆过程

## 数据传入
数据传入的主要操作是将```mxArray```类的对象中封装的数据读取到便于操作的C++数据类型。常见的MatLab数据类型，如标量、向量、矩阵、张量，在```mxArray```类的底层以一维数组的形式存储。示例如下：
```C++
//demo_mex.cpp
#include "mex.h"
#define mat  prhs[0]
void mexFunction(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]) {
    double* mat_ptr = mxGetPr(mat); //获取指向mat矩阵的数据指针
    int m = mxGetM(mat); //获取矩阵第一个维度
    int n = mxGetN(mat); //获取矩阵第二个维度
    ...
}
 ```
需要注意的是，MatLab提供的读取张量、矩阵维度的函数只有```mxGetM```和```mxGetN```，而从MatLab端传入的张量维度数量并未做限制。因此以上写法中的第二个维度仅对二维张量也就是矩阵是正确的。若传入的是高维张量，```mxGetM```能够正确获取第一个维度，而```mxGetN```返回的是除第一个维度外所有维度的乘积。

## 数据处理
数据处理部分包含了主要的运算逻辑，这部分的写法较为灵活。因为不涉及与MatLab的数据通信，这部分理论上可以使用MEX支持的C++标准下的所有feature。数据处理部分涉及一些值得注意的细节：
- MatLab下标从1开始，而C++下标从0开始。因此如果使用从MatLab端传入的坐标，或坐标需要计算得到，应注意此时的坐标是MatLab坐标，在C++中使用时应-1
- MatLab的向量、矩阵、张量在内存中以列优先方式存储，而C++的存储方式是行优先。这部分的区别在访问从```mxArray```类对象获取的一维数据指针时十分重要。但若后续将一维数据恢复为高维的矩阵、张量，如二维数组或```vector<vector<double> >```，此时MatLab与C++对矩阵元素的访问都是一致的，即先行再列。

见下列示例代码：
```C++
//demo_mex.cpp
void add1(double* mat_ptr, vector<vector<double> >& mat_vec, int m, int n){ 
    //功能：对应点位置+1
    for(int y = 0; y < m; y++){
        for(int x = 0; x < n; x++){
            mat_vec[y][x] = mat_ptr[x * m + y] + 1;
            //mat_ptr[x * m + y]对应MatLab中mat(y, x)
        }
    }
}
 ```
 另外需要注意的是，prhs和plhs并非全局变量，而是```mexFunction```的参数。如果要在被调函数中使用这两个指针数组，需要将prhs和plhs这两个数组首地址作为参数传入。

 ## 结果返回
 计算结果的返回大致流程如下：
 - 创建结果矩阵，用对应的plhs指针指向被创建的```mxArray```类对象。
 - 获取创建的```mxArray```类对象的数据指针，按照行优先的方式，根据计算结果为其赋值。
   - *获取```mxArray```类对象的数据指针是必须的步骤，因为```mxArray```类对象没有重载赋值运算符，不能直接赋值，因此只能获取其数据指针后，通过指针进行赋值。*
